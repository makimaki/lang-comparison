:lang: ja
:toc: left
:toclevels: 2
:toc-title: 目次
:sectnums:
:sectnumlevels: 2
:sectlinks:
:imagesdir: ./images
:docname: アーキテクチャ選定の為の技術調査(開発言語比較)
:icons: font
:source-highlighter: pygments

= アーキテクチャ選定の為の技術調査(開発言語比較)

== モチベーション

新規または既存プロダクト開発において、今後アーキテクチャを選定するに当たっての準備として、社内や個人的に知見の無い言語を実際に使用し、共通の観点で現在最も使用している Scala との比較を行う。

== 実装内容

スグレスの機能を一部置き換えるようなものを検討したが、あまり時間も取れず学習にも時間を取られ、クラウド(GCP)なども絡んでくるとたちまち難易度も上がってくるため、 LINE の簡単なオオム返し(+α)ボットの実装を行うだけにとどめた。

.機能仕様
* 「あなたは誰ですか？」のテキストメッセージに対して「〇〇(実装言語) で実装された何かです」を応答する。
* 上記以外のテキストメッセージに対して「〇〇(入力メッセージ) ですね。わかります。」を応答する。
* ロケーションメッセージに対して、送信された位置のタイトルを表示し、 Google Maps で開きたいかを問うボタンを返答する。
** ボタンには、送信された位置の緯度経度から生成した Google Maps の URL を Postback Data としてセットする。
** 上記のボタン押下で受け取ったポストバックリクエストに対し、 Postback Data にセットされた値を URI にしたボタンを再度返却する。

== 対象言語

.Rust
[%collapsible]
====
Framework:: actix-web
Json Parser:: serde-json
Source:: link:rust-study[]
====

.Go
[%collapsible]
====
Framework:: Gin
Json Parser:: encoding/json
Source:: link:go-study[]
====

.Scala
[%collapsible]
====
Framework:: Play Framework / Scalatra
Json Parser:: play-json
Source:: link:scala-study[]
====

(Kotlin / Python / JavaScript(TypeScript) なども候補に上げていたが、時間の関係で今回は見送った。)

== 比較

個人的な趣味趣向も含まれている為、偏りはあるが、実際に触れてみての所感を記載する。

=== サマリー

[format="csv",cols=">s,^m,^m,^m,^m,^m,^m,^m,^s",options="header"]
|===
include::summary.csv[]
|===

[TIP]
=====
.一般的な他言語と比べて...
----
5 .. 非常に優位性がある
4 .. 優位性がある
3 .. 標準的
2 .. 課題あり
1 .. 採用には難がある 
----
=====

=== 学習コスト

==== Rust

* 高級言語の革を被った低級言語という印象であり、ゼロコスト抽象化を意識した実装や設計の理解がとにかくややこしい。
* 学習時間もそれほど取れなかったため、まだあまり理解できていない部分も多い。
* 適当に書いているとパフォーマンスが最適化されなかったり、所有権/借用/ライフタイム等書き手に委ねられる概念も多い。

==== Go

* 覚えることは少なく、見様見真似で適当に書いても割とちゃんと動く。
* パッケージ管理には今後デファクトになると思われる Go Modules を使用してみたが、この辺の詳細はまだあまりわかってな部分も多い。

==== Scala

* 散々使っているのでバイアスが掛かっている部分はあるが…
** 一般的には implicit や Future 等が覚えるまでややこしい。
* Rust にも共通すると思うが…
** 基本 immutable な実装というのも慣れていないと難しい。
** 基本として抑えておくべき構文等が多い。

=== クラウドとの親和性

実行環境としての差は(Lambda / Cloud Function や Beanstalk / App Engine のようなものを除いて)それほどないと思うので、今回は単純に SDK の有無という意味合いで記載。

==== Rust

* 基本的に、公式サポートはなさそう。
** AWS / Azure に関してはサードパーティの SDK は存在するようだが、品質やサポート範囲(サービス)については未確認
** GCP については、 Google APIs 向けのライブラリしか存在しなかったので、ほぼ直接 API をコールするような形になってしまう。

==== Go

* 主要なクラウドサービスは公式にサポートしており、主要言語の1つとして位置づけられている。

==== Scala

* Java が公式にサポートされている。
** ネイティブサポートされているわけではなく、 Java のライブラリを使用する必要がある関係上、使い勝手に難があることもあるので、 4 とした。
** Java のライブラリをラップする形で、 Scala 向けのサードパーティライブラリが提供されている場合もあるが、品質や将来性を考慮すると積極的に採用できるものではない。

=== エコシステムの成熟度

==== Rust

* 後発言語に共通して言えるが、公式に提供される周辺の枠組みが整っている印象がある。
* サードパーティの仕組みが乱立していないことは、捉えようによっては良いことのようにも思う。
* async/await 構文の導入で Web 界隈でも最近採用が活発化して来ている(？)ようなので、特に Web 周辺ではこれから整っていく部分も多いように思う。
** 今回、 Web フレームワークとして actix-web を使用したが、破壊的な変更がまだ頻繁に入っているような様子だった。
* どういった背景があるのか詳しく調べられていないが、依存ライブラリまでソースコードから毎回コンパイルされているようで、思ったよりもビルド時間が長い(特に --release ビルド時)問題があったが、 sccache を使用することでだいぶ改善された。
* async/await 構文に対応したライブラリがまだ少なく、変に混在させると非同期処理をブロックさせてしまう。

==== Go

* 数年前から様々なプロダクト/プロジェクトで採用実績もあり、周辺技術もだいぶ枯れてきている印象。

==== Scala

* Java の膨大な資産をそのまま使えるのがとにかく強み。

=== 言語仕様・機能性

==== Rust

* まだあまり理解しきれていない部分も多いが、 Scala にも引けを取らない強力な型システムが備わっており、必要十分な機能があるように思う。
* 非同期処理周りが、 async/await 構文にようやく落ち着いた？(Scala と同等のものかわからないが、過去には future なども存在した模様)

==== Go

* オブジェクト指向に慣れ親しんだ、個人的な感覚ではあるが‥
** 継承がないのが辛い(interface で近いことはできるが)。
** ジェネリクスがないのが辛い。
** エラーハンドリングがとにかくめんどくさい。 `+if err != nil {}+` 地獄は言語仕様レベルでなんとかして欲しい。
* ちょっとしたものを作る分には問題ないが、ある程度の規模になってくると言語仕様の貧弱さに因る冗長性や抽象度の低さが気になってくると思われる(たぶん、設計思想的に頭を切り替えないといけないのだが‥)。

==== Scala

* 個人的には概ね気に入っている。
** 業務アプリケーションを実装する上で頻繁に使うコレクション操作のメソッドが充実。
** 関数型とオブジェクト指向のハイブリッド。
** 困ったら Java の資産に頼れる。

=== 実装コスト

Web API 周辺は大したことをやっておらず大差もないので、 Json の取り扱いに着目して比較する。

==== Rust

* 慣れの問題もあるとは思うが文字列(&str と String)の扱いが面倒。
** `to_string()` がたくさん。
* Json を扱うに当たって、恐らくデファクトである serde がとても優秀。
** コーディング無しで動的なスキーマの Json が表現できる。
** Json に限らず様々なフォーマットのシリアライズ/デシリアライズが共通のライブラリ行える。

==== Go

* 型システムが貧弱な為、 Json のパースがとにかくやりにくい。
** 構造体でスキーマを表現しようとせずに、実装でゴニョゴニョやってしまえば気にならないと思うが‥。
** 動的なスキーマに対応するためには、次のいずれかのアプローチを取る必要がある。
*** 動的に切り替わる可能性があるスキーマの全てのフィールドを持った構造体を用意し、 type 等のフィールドに基づいて、参照すべきフィールドを意識する。LINE の SDK はこのアプローチで実装されているようだった。
*** 動的なオブジェクトが入るフィールドは、それぞれのフィールド構成の構造体を定義した上で `interface{}` で構造体を定義し、 type 等のフィールドの値に基づいて、 `interface{}` のフィールドをキャストする。今回は SDK を使わずに、自前でこのアプローチを使った実装を行った。

==== Scala

* スグレスで使用している play-json 以外のライブラリを使ってみようかと思ったが、時間の都合上 play-json で済ませた。
** 個人的に以前 circe を使ってみたことがあるが、 play-json と同じような感覚で使用できた(気がする)。

=== 実行パフォーマンス

別途ベンチマークをとっているので省略。

=== 将来性

==== Rust

* 2019年〜2020年にかけて、特に活発化しているように見える。
** async/await 構文の実装も大きい？

==== Go

* Kubernetes 等で採用されているというのは大きい。
** 不特定多数のコミッターが存在する OSS プロジェクトでは、特に真価を発揮するのかと思う。

==== Scala

* Rust / Go に比べると注目度は低いが、廃れてもいない(と思う)

== ベンチマーク

Gatling で実装した機能を総ナメするシナリオを実行する負荷試験を行った。
メッセージの応答に LINE Reply API へのリクエストが必要な部分については、ダミーAPIを建てるとそちら側がボトルネックになってしまうので、レスポンスで直接応答するモードを実装して対応した。

heaviside step function に依って、山なりにリクエスト数が増えていくようにして1分間でシナリオを n 回実行するようにしてテストした。

link:reports[]

.実行結果の概要
n=5000::
すべて途中でタイムアウト。

n=2000::
すべてエラーにならず処理できた。

n=4500:: 
Rust 以外はエラーにならず処理できた。 +
(Scala は恐らくギリギリで、途中でエラーになることもあった。)

n=3750::
Rust がどこまでいけるのかを試したところ、ここが限界であった。

.備考
* Rust に関しては、1リクエスト辺りの処理能力は Go に近いパフォーマンスで処理できていたので、リクエストがつまりだした時点でサーキットブレーカー的なものが働いている？
** framework 側の問題や設定・チューニングで変わってくる可能性も。
* もしくは、実装の問題でどこかでブロッキングしてしまっている所為で思ったようにさばききれていない？

== おまけ

link:https://github.com/ALBERT-Inc/albot-docs/pull/19[gRPC の似たような比較]
